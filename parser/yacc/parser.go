// Code generated by goyacc -l -o parser/yacc/parser.go parser/yacc/kaleido_grammar.y. DO NOT EDIT.
/*
MIT License

Copyright (c) 2021 Vincent Hiribarren

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

package yacc

import __yyfmt__ "fmt"

import (
	"errors"
	"github.com/vhiribarren/tuto-llvm-kaleidoscope-golang/lexer"
	"github.com/vhiribarren/tuto-llvm-kaleidoscope-golang/parser"
	"log"
	"unicode/utf8"
)

type yySymType struct {
	yys      int
	token    lexer.KaleidoTokenContext
	proto    parser.PrototypeAST
	function parser.FunctionAST
	expr     parser.ExprAST
	argList  parser.ArgList
	exprList parser.ExprList
	program  parser.ProgramAST
	number   parser.NumberExprAST
	variable parser.VariableExprAST
}

const DEF = 57346
const EXTERN = 57347
const NUMBER = 57348
const IDENTIFIER = 57349

var yyToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"DEF",
	"EXTERN",
	"NUMBER",
	"'<'",
	"'+'",
	"'-'",
	"'*'",
	"IDENTIFIER",
	"'('",
	"';'",
	"')'",
	"','",
}

var yyStatenames = [...]string{}

const yyEofCode = 1
const yyErrCode = 2
const yyInitialStackSize = 16

const EOF = 0

type parserContext struct {
	lexer.KaleidoLexer
	result *parser.ProgramAST
	err    error
}

func (s *parserContext) Lex(lval *yySymType) int {
	tokenContext := s.NextToken()
	lval.token = *tokenContext
	switch tokenContext.Token {
	case lexer.KTokenEOF:
		return EOF
	case lexer.KTokenDef:
		return DEF
	case lexer.KTokenExtern:
		return EXTERN
	case lexer.KTokenIdentifier:
		return IDENTIFIER
	case lexer.KTokenNumber:
		return NUMBER
	default:
		val, _ := utf8.DecodeRuneInString(tokenContext.Value)
		return int(val)
	}
}

func (s *parserContext) Error(e string) {
	s.result = nil
	s.err = errors.New(e)
}

func BuildKaleidoAST(buffer string) (*parser.ProgramAST, error) {
	context := &parserContext{KaleidoLexer: lexer.NewKaleidoLexer(buffer)}
	yyParse(context)
	if context.result == nil {
		return nil, context.err
	}
	return context.result, nil
}

var yyExca = [...]int{
	-1, 1,
	1, -1,
	-2, 0,
}

const yyPrivate = 57344

const yyLast = 53

var yyAct = [...]int{
	8, 22, 20, 21, 23, 39, 38, 27, 36, 6,
	7, 10, 41, 25, 10, 40, 9, 12, 26, 9,
	12, 29, 30, 31, 32, 35, 22, 20, 21, 23,
	28, 14, 20, 21, 23, 24, 18, 23, 17, 13,
	42, 1, 2, 5, 15, 16, 19, 3, 4, 34,
	33, 37, 11,
}

var yyPact = [...]int{
	-1000, -1000, 5, 18, 18, 18, 25, 25, 19, 23,
	-1000, -1000, 8, -1000, -1000, -1000, -1000, 8, -5, 17,
	8, 8, 8, 8, 8, -6, 19, -1000, -1000, 27,
	27, 24, -1000, -8, -10, 19, -1000, 1, -1000, 8,
	-1000, -1000, 19,
}

var yyPgo = [...]int{
	0, 0, 52, 51, 50, 49, 38, 48, 47, 43,
	42, 41, 39,
}

var yyR1 = [...]int{
	0, 11, 10, 10, 10, 10, 12, 12, 8, 7,
	9, 1, 1, 1, 1, 1, 1, 1, 1, 2,
	4, 4, 5, 5, 6, 3, 3,
}

var yyR2 = [...]int{
	0, 1, 3, 3, 3, 0, 1, 0, 3, 3,
	1, 1, 1, 1, 3, 3, 3, 3, 3, 4,
	1, 0, 3, 1, 4, 2, 0,
}

var yyChk = [...]int{
	-1000, -11, -10, -8, -7, -9, 4, 5, -1, 11,
	6, -2, 12, -12, 13, -12, -12, -6, 11, -6,
	8, 9, 7, 10, 12, -1, -1, 12, 13, -1,
	-1, -1, -1, -4, -5, -1, 14, -3, 14, 15,
	14, 11, -1,
}

var yyDef = [...]int{
	5, -2, 1, 7, 7, 7, 0, 0, 10, 11,
	12, 13, 0, 2, 6, 3, 4, 0, 0, 0,
	0, 0, 0, 0, 21, 0, 8, 26, 9, 15,
	16, 17, 18, 0, 20, 23, 14, 0, 19, 0,
	24, 25, 22,
}

var yyTok1 = [...]int{
	1, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	12, 14, 10, 8, 15, 9, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 13,
	7,
}

var yyTok2 = [...]int{
	2, 3, 4, 5, 6, 11,
}

var yyTok3 = [...]int{
	0,
}

var yyErrorMessages = [...]struct {
	state int
	token int
	msg   string
}{}

/*	parser for yacc output	*/

var (
	yyDebug        = 0
	yyErrorVerbose = false
)

type yyLexer interface {
	Lex(lval *yySymType) int
	Error(s string)
}

type yyParser interface {
	Parse(yyLexer) int
	Lookahead() int
}

type yyParserImpl struct {
	lval  yySymType
	stack [yyInitialStackSize]yySymType
	char  int
}

func (p *yyParserImpl) Lookahead() int {
	return p.char
}

func yyNewParser() yyParser {
	return &yyParserImpl{}
}

const yyFlag = -1000

func yyTokname(c int) string {
	if c >= 1 && c-1 < len(yyToknames) {
		if yyToknames[c-1] != "" {
			return yyToknames[c-1]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func yyStatname(s int) string {
	if s >= 0 && s < len(yyStatenames) {
		if yyStatenames[s] != "" {
			return yyStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func yyErrorMessage(state, lookAhead int) string {
	const TOKSTART = 4

	if !yyErrorVerbose {
		return "syntax error"
	}

	for _, e := range yyErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + yyTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := yyPact[state]
	for tok := TOKSTART; tok-1 < len(yyToknames); tok++ {
		if n := base + tok; n >= 0 && n < yyLast && yyChk[yyAct[n]] == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if yyDef[state] == -2 {
		i := 0
		for yyExca[i] != -1 || yyExca[i+1] != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; yyExca[i] >= 0; i += 2 {
			tok := yyExca[i]
			if tok < TOKSTART || yyExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if yyExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += yyTokname(tok)
	}
	return res
}

func yylex1(lex yyLexer, lval *yySymType) (char, token int) {
	token = 0
	char = lex.Lex(lval)
	if char <= 0 {
		token = yyTok1[0]
		goto out
	}
	if char < len(yyTok1) {
		token = yyTok1[char]
		goto out
	}
	if char >= yyPrivate {
		if char < yyPrivate+len(yyTok2) {
			token = yyTok2[char-yyPrivate]
			goto out
		}
	}
	for i := 0; i < len(yyTok3); i += 2 {
		token = yyTok3[i+0]
		if token == char {
			token = yyTok3[i+1]
			goto out
		}
	}

out:
	if token == 0 {
		token = yyTok2[1] /* unknown char */
	}
	if yyDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", yyTokname(token), uint(char))
	}
	return char, token
}

func yyParse(yylex yyLexer) int {
	return yyNewParser().Parse(yylex)
}

func (yyrcvr *yyParserImpl) Parse(yylex yyLexer) int {
	var yyn int
	var yyVAL yySymType
	var yyDollar []yySymType
	_ = yyDollar // silence set and not used
	yyS := yyrcvr.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	yystate := 0
	yyrcvr.char = -1
	yytoken := -1 // yyrcvr.char translated into internal numbering
	defer func() {
		// Make sure we report no lookahead when not parsing.
		yystate = -1
		yyrcvr.char = -1
		yytoken = -1
	}()
	yyp := -1
	goto yystack

ret0:
	return 0

ret1:
	return 1

yystack:
	/* put a state and value onto the stack */
	if yyDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", yyTokname(yytoken), yyStatname(yystate))
	}

	yyp++
	if yyp >= len(yyS) {
		nyys := make([]yySymType, len(yyS)*2)
		copy(nyys, yyS)
		yyS = nyys
	}
	yyS[yyp] = yyVAL
	yyS[yyp].yys = yystate

yynewstate:
	yyn = yyPact[yystate]
	if yyn <= yyFlag {
		goto yydefault /* simple state */
	}
	if yyrcvr.char < 0 {
		yyrcvr.char, yytoken = yylex1(yylex, &yyrcvr.lval)
	}
	yyn += yytoken
	if yyn < 0 || yyn >= yyLast {
		goto yydefault
	}
	yyn = yyAct[yyn]
	if yyChk[yyn] == yytoken { /* valid shift */
		yyrcvr.char = -1
		yytoken = -1
		yyVAL = yyrcvr.lval
		yystate = yyn
		if Errflag > 0 {
			Errflag--
		}
		goto yystack
	}

yydefault:
	/* default state action */
	yyn = yyDef[yystate]
	if yyn == -2 {
		if yyrcvr.char < 0 {
			yyrcvr.char, yytoken = yylex1(yylex, &yyrcvr.lval)
		}

		/* look through exception table */
		xi := 0
		for {
			if yyExca[xi+0] == -1 && yyExca[xi+1] == yystate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			yyn = yyExca[xi+0]
			if yyn < 0 || yyn == yytoken {
				break
			}
		}
		yyn = yyExca[xi+1]
		if yyn < 0 {
			goto ret0
		}
	}
	if yyn == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			yylex.Error(yyErrorMessage(yystate, yytoken))
			Nerrs++
			if yyDebug >= 1 {
				__yyfmt__.Printf("%s", yyStatname(yystate))
				__yyfmt__.Printf(" saw %s\n", yyTokname(yytoken))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for yyp >= 0 {
				yyn = yyPact[yyS[yyp].yys] + yyErrCode
				if yyn >= 0 && yyn < yyLast {
					yystate = yyAct[yyn] /* simulate a shift of "error" */
					if yyChk[yystate] == yyErrCode {
						goto yystack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if yyDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", yyS[yyp].yys)
				}
				yyp--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if yyDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", yyTokname(yytoken))
			}
			if yytoken == yyEofCode {
				goto ret1
			}
			yyrcvr.char = -1
			yytoken = -1
			goto yynewstate /* try again in the same state */
		}
	}

	/* reduction by production yyn */
	if yyDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", yyn, yyStatname(yystate))
	}

	yynt := yyn
	yypt := yyp
	_ = yypt // guard against "declared and not used"

	yyp -= yyR2[yyn]
	// yyp is now the index of $0. Perform the default action. Iff the
	// reduced production is ε, $1 is possibly out of range.
	if yyp+1 >= len(yyS) {
		nyys := make([]yySymType, len(yyS)*2)
		copy(nyys, yyS)
		yyS = nyys
	}
	yyVAL = yyS[yyp+1]

	/* consult goto table to find next state */
	yyn = yyR1[yyn]
	yyg := yyPgo[yyn]
	yyj := yyg + yyS[yyp].yys + 1

	if yyj >= yyLast {
		yystate = yyAct[yyg]
	} else {
		yystate = yyAct[yyj]
		if yyChk[yystate] != -yyn {
			yystate = yyAct[yyg]
		}
	}
	// dummy call; replaced with literal code
	switch yynt {

	case 1:
		yyDollar = yyS[yypt-1 : yypt+1]
		{
			yyVAL.program = yyDollar[1].program
			yylex.(*parserContext).result = &yyVAL.program
		}
	case 2:
		yyDollar = yyS[yypt-3 : yypt+1]
		{
			yyDollar[1].program.Funcs = append(yyDollar[1].program.Funcs, yyDollar[2].function)
			yyVAL.program = yyDollar[1].program
		}
	case 3:
		yyDollar = yyS[yypt-3 : yypt+1]
		{
			yyDollar[1].program.Protos = append(yyDollar[1].program.Protos, yyDollar[2].proto)
			yyVAL.program = yyDollar[1].program
		}
	case 4:
		yyDollar = yyS[yypt-3 : yypt+1]
		{
			yyDollar[1].program.Funcs = append(yyDollar[1].program.Funcs, yyDollar[2].function)
			yyVAL.program = yyDollar[1].program
		}
	case 5:
		yyDollar = yyS[yypt-0 : yypt+1]
		{
			yyVAL.program = parser.ProgramAST{}
		}
	case 8:
		yyDollar = yyS[yypt-3 : yypt+1]
		{
			yyVAL.function = parser.FunctionAST{Prototype: yyDollar[2].proto, Body: yyDollar[3].expr}
		}
	case 9:
		yyDollar = yyS[yypt-3 : yypt+1]
		{
			yyVAL.proto = yyDollar[2].proto
		}
	case 10:
		yyDollar = yyS[yypt-1 : yypt+1]
		{
			yyVAL.function = parser.FunctionAST{Prototype: parser.PrototypeAST{FunctionName: "__main__", Args: []string{}}, Body: yyDollar[1].expr}
		}
	case 11:
		yyDollar = yyS[yypt-1 : yypt+1]
		{
			yyVAL.expr = parser.VariableExprAST(yyDollar[1].token.Value)
		}
	case 12:
		yyDollar = yyS[yypt-1 : yypt+1]
		{
			yyVAL.expr = parser.NumberExprAST(yyDollar[1].token.Value)
		}
	case 14:
		yyDollar = yyS[yypt-3 : yypt+1]
		{
			yyVAL.expr = yyDollar[2].expr
		}
	case 15:
		yyDollar = yyS[yypt-3 : yypt+1]
		{
			yyVAL.expr = &parser.BinaryExprAST{LHS: yyDollar[1].expr, RHS: yyDollar[3].expr, Op: '+'}
		}
	case 16:
		yyDollar = yyS[yypt-3 : yypt+1]
		{
			yyVAL.expr = &parser.BinaryExprAST{LHS: yyDollar[1].expr, RHS: yyDollar[3].expr, Op: '-'}
		}
	case 17:
		yyDollar = yyS[yypt-3 : yypt+1]
		{
			yyVAL.expr = &parser.BinaryExprAST{LHS: yyDollar[1].expr, RHS: yyDollar[3].expr, Op: '<'}
		}
	case 18:
		yyDollar = yyS[yypt-3 : yypt+1]
		{
			yyVAL.expr = &parser.BinaryExprAST{LHS: yyDollar[1].expr, RHS: yyDollar[3].expr, Op: '*'}
		}
	case 19:
		yyDollar = yyS[yypt-4 : yypt+1]
		{
			log.Println("Parsed rule: FuncExpr")
			yyVAL.expr = &parser.CallExprAST{FunctionName: yyDollar[1].token.Value, Args: yyDollar[3].exprList}
		}
	case 21:
		yyDollar = yyS[yypt-0 : yypt+1]
		{
			yyVAL.exprList = []parser.ExprAST{}
		}
	case 22:
		yyDollar = yyS[yypt-3 : yypt+1]
		{
			yyVAL.exprList = append(yyDollar[1].exprList, yyDollar[3].expr)
		}
	case 23:
		yyDollar = yyS[yypt-1 : yypt+1]
		{
			yyVAL.exprList = []parser.ExprAST{yyDollar[1].expr}
		}
	case 24:
		yyDollar = yyS[yypt-4 : yypt+1]
		{
			yyVAL.proto = parser.PrototypeAST{FunctionName: yyDollar[1].token.Value, Args: yyDollar[3].argList}
		}
	case 25:
		yyDollar = yyS[yypt-2 : yypt+1]
		{
			yyVAL.argList = append(yyDollar[1].argList, yyDollar[2].token.Value)
		}
	case 26:
		yyDollar = yyS[yypt-0 : yypt+1]
		{
			yyVAL.argList = []string{}
		}
	}
	goto yystack /* stack new state and value */
}
